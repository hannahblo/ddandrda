% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/definition_formal_context.R
\name{compute_conceptual_scaling}
\alias{compute_conceptual_scaling}
\title{Computes the formal context based on input data and scaling method.}
\usage{
compute_conceptual_scaling(
  input_factor = NULL,
  input_ordinal_numeric = NULL,
  input_spatial = NULL,
  input_porder = NULL,
  scaling_methods = NULL,
  input_check = TRUE
)
}
\arguments{
\item{input_factor}{(NULL or vector of factor values)}

\item{input_ordinal_numeric}{(NULL or vector of ordinal/numeric values)}

\item{input_spatial}{(NULL or list of two dimensional vectors)}

\item{input_porder}{(NULL or list of square same sized matrices)}

\item{scaling_methods}{(NULL or vector containing "porder_edge" or/and
"ordinal")}

\item{input_check}{(logical)}
}
\value{
dataframe representing the crosstable/formal context
}
\description{
This function computes the formal context for nominal, inter-
ordinal, spatial and partial order data points. Note that for each
observation different data types can be observed. In each case the objects of
the formal context are the observation.

Tho following data types can be transferred to a formal context by this
method:
\itemize{
\item factor obersavtion: Here the standard nominal scaling method is implemented
see: Ganter, B., Will, R. (2008): Formale Begriffsanalyse,
Mathematische Grundlagen, Springer
\item oridnal observation: The ordinal and interordinal scaling method is
implemented. If not included into scaling_methods, the interordinal scaling
is applyed. If not, then include "ordinal" to the vector or scaling methods.
see: Ganter, B., Will, R. (2008): Formale Begriffsanalyse,
Mathematische Grundlagen, Springer
\item spatial observation: TODO not done yet
\item partial order observations: The attributes are either only if a relation
between two items exits or also that the relation does not exist. The default
method is the formal context with relation exists and not exists attributes.
If "porder_edge" is included to the vecotr of scaling_methods, then only the
relation exits part is computed.
}
}
\examples{
attr_numeric_4 <- as.numeric(c(1.2, 1, 1.6, 2))
attr_nominal_4 <- as.factor(c("factor_1", "factor_2",
                               "factor_2", "factor_1"))
compute_conceptual_scaling(input_factor = attr_nominal_4,
                           input_ordinal_numeric = attr_numeric_4)

relation_1 <- matrix(0, ncol = 4, nrow = 4)
diag(relation_1) <- 1
relation_2 <- relation_1
relation_2[1, c(2,3,4)] <- 1
relation_2[2, c(3,4)] <- 1
relation_2[3, 4] <- 1
list_porder_1 <- list(relation_1, relation_2)
compute_conceptual_scaling(input_porder = list_porder_1)
compute_conceptual_scaling(input_porder = list_porder_1,
                           scaling_methods = c("porder_edge"))

}
